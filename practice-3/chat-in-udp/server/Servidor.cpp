/* Servidor.cpp - Generated by Visual Multi-Thread Win32 */

// WIN32_LEAN_AND_MEAN macro prevents the Winsock.h from being 
// included by the Windows.h header
#define WIN32_LEAN_AND_MEAN

// The Winsock2.h header file contains most of the Winsock functions, 
// structures, and definitions. The Ws2tcpip.h header file contains 
// definitions introduced in the WinSock 2 Protocol-Specific
// The Winsock2.h header file internally includes core elements from 
// the Windows.h header file
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdlib.h>
#include <stdio.h>
#include "AppObjects.h"
#include "my_socket.h"
// Need to link with Ws2_32.lib
#pragma comment (lib, "Ws2_32.lib")

ClientList clientList;

void cleanUp() {
	for (int i = 0; i < 10; i++)
	{
		Client *client = &clientList.clients[i];
		if (client->socket == 0 && client->socket != INVALID_SOCKET)
		{
			closesocket(client->socket);
			client->socket = INVALID_SOCKET;
			client->used   = false;
		}
	}
}

void initializeClientList(ClientList list)
{
	list.current = NULL;
	
	for (int i = 0; i < 10; i++)
	{
		Client *client = &list.clients[i];
		client->enabled = true;
		client->id = 0;
		client->socket = INVALID_SOCKET;
		client->used = false;
	}
}


DWORD WINAPI thread_Servidor(LPVOID lpParameter);
extern DWORD WINAPI thread_ServerInstance(ClientList *lpParameter);

DWORD WINAPI thread_Servidor(LPVOID lpParameter)
{
	WSADATA wsaData;
	int iResult;
	SOCKET Server_Socket = INVALID_SOCKET;
	Client clients[10];
	
	clientList.clients = clients;
	int count_socket = 0;

	initializeClientList(clientList);

	struct addrinfo *result = NULL;
	struct addrinfo hints;
	int recvbuflen = DEFAULT_BUFLEN;

	printf("Sistemas Distribuidos: Servidor MultiThread Inicializando ...\n");

	SocketParams *params;
	params = (SocketParams *)lpParameter;

	//Initialize Winsock
	// The WSAStartup function is called to initiate use of WS2_32.dll
	// The MAKEWORD(2,2) parameter of WSAStartup makes a request for 
	// version 2.2 of Winsock on the system
	iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (iResult != 0)
	{
		printf("WSAStartup failed with error: %d\n", iResult);
		return 1;
	}

	ZeroMemory(&hints, sizeof(hints));
	// Internet address family is unspecified so that either an 
	// IPv6 or IPv4 address can be returned. The application requests 
	// the socket type to be a stream socket for the TCP protocol
	hints.ai_family = params->family;
	hints.ai_socktype = params->socktype;
	hints.ai_protocol = params->protocol;
	hints.ai_flags = params->flags;

	/* Resolve the server address and port */
	iResult = getaddrinfo(NULL, params->port, &hints, &result);

	if (iResult != 0) {
		printf("getaddrinfo failed with error: %d\n", iResult);
		WSACleanup();
		return 1;
	}
	/* Create a SOCKET for connecting to server
	   After initialization, a SOCKET object must be instantiated for use by the server */
	Server_Socket = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
	if (Server_Socket == INVALID_SOCKET) {
		printf("socket failed with error: %ld\n", WSAGetLastError());
		freeaddrinfo(result);
		WSACleanup();
		return 1;
	}

	/* Setup the TCP listening socket
	   For a server to accept client connections, it must be bound to a network
	   address within the system. The following code demonstrates how to bind a
	   socket that has already been created to an IP address and port. Client
	   applications use the IP address and port to connect to the host network. */
	iResult = bind(Server_Socket, result->ai_addr, (int)result->ai_addrlen);
	if (iResult == SOCKET_ERROR) {
		printf("bind failed with error: %d\n", WSAGetLastError());
		freeaddrinfo(result);
		closesocket(Server_Socket);
		WSACleanup();
		return 1;
	}

	/* Listen
	   After the socket is bound to an IP address and port on the system,
	   the server must then listen on that IP address and port for incoming
	   connection requests. */
	iResult = listen(Server_Socket, SOMAXCONN);
	if (iResult == SOCKET_ERROR) {
		printf("listen failed with error: %d\n", WSAGetLastError());
		closesocket(Server_Socket);
		WSACleanup();
		return 1;
	}

	/* Accept a client socket and create a thread to manage each accepted connection */
	while (true)
	{
		//	Once the socket is listening for a connection, the program 
		// must handle connection requests on that socket.
		int i;
		for (i = 0; i < 10; i++) {
			if (!clientList.clients[i].used) {
				break;
			}
		}

		clientList.clients[i].id = i + 1;
		clientList.clients[i].used = clientList.clients[i].enabled = true;
		clientList.clients[i].socket = accept(Server_Socket, NULL, NULL);
		clientList.current = &clientList.clients[i];

		if (clientList.clients[i].socket == INVALID_SOCKET)
		{
			printf("accept failed with error: %d\n", WSAGetLastError());
			closesocket(clientList.clients[i].socket);
			clientList.clients[i].used = false;
			WSACleanup();
			return 1;
		}
		else
		{
			ServerInstance = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)thread_ServerInstance, &clientList, 0, 0);
			count_socket++;
		}
		Sleep(10);
	}

	return 0;
}
