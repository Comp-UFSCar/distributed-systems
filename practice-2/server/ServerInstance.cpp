/* ServerInstance.cpp - Generated by Visual Multi-Thread Win32 */

#undef UNICODE
#define WIN32_LEAN_AND_MEAN


#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdlib.h>
#include <stdio.h>
#include "AppObjects.h"
#include "my_socket.h"

// Need to link with Ws2_32.lib
#pragma comment (lib, "Ws2_32.lib")

#include "AppObjects.h"

bool checkOperation (message message, Client client){
	if (!strcmp(message.buf, CLIENT_OP_DISABLE)) {
		client.enabled = false;
		return true;
	}
	if (!strcmp(message.buf, CLIENT_OP_ENABLE)){
		client.enabled = true;
		return true;
	}

	return false;
}

int sendAll(ClientList clientList, Client current, message message) {
	for (int i = 0; i < 10; i++) {
		if (!clientList.clients[i].used || i == current.id -1) {
			continue;
		}

		int result = send(clientList.clients[i].socket, (const char *)&message, DEFAULT_BUFLEN, 0);

		if (result == SOCKET_ERROR) {
			printf("send failed with error: %d\n", WSAGetLastError());
			closesocket(clientList.clients[i].socket);
			WSACleanup();
			return 1;
		}

		return 0;
		/*printf("Bytes sent: %d\n", result);
		printf("Server sent = %s\n\n", message.buf);*/
	}
}

DWORD WINAPI thread_ServerInstance(ClientList *lpParameter);

DWORD WINAPI thread_ServerInstance(ClientList *lpParameter)
{
	int result;
	int iSendResult;
	int recvbuflen = DEFAULT_BUFLEN;

	ClientList clientList;
	clientList = *lpParameter;
	Client current = clientList.current;
	message message;

	/* Receive until the peer shuts down the connection */
	while (true)
	{
		result = recv(current.socket, (char *)&message, DEFAULT_BUFLEN, 0);

		// Check for error or the closing of the connection
		if (result == 0) break;
		if (message.buf[0] == '0') { printf("Close: %s\n\n", message.name); break; }
		if (result == -1) { printf("Close: %s\n\n", message.name); break; }
		
		printf("%s:  %s\n", message.name, message.buf);

		bool isOperation = checkOperation(message, current);
		if (!isOperation) {
			sendAll(clientList, current, message);
		}

		Sleep(10);	
	}
	
	current.used = false;
	closesocket(current.socket);
	return 0;
}
